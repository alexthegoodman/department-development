# Django (Book Notes)
* Style Conventions
	* PEP 8
	* 79 char limit per line
	* Imports should be grouped
		* Standard library (Python, stdlib)
		* Related third-party (Django)
		* Local app imports
	* use relative imports like .models over cones.models when possible (.., …?)
	* https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/
* fixtures a good for pre-populating data, but are not dynamic like Factories
* Virtualenv is a tool for creating isolated Python environments for maintaining package dependencies. Allows separate project’s dependencies.
	* virtualenvwrapper enables you start the (virualenvironment) without typing the whole path
	* Set your virtualenv PYTHONPATH so that Django-admin.py can be used to serve site and perform tasks
	* if that is too complicated, stick with manage.py
	* commonly all virtualenvs for all projects are technically housed in a single, separate directory
* App scaffolding
	* Recommended as _repo_root_project_root_conf_root_
	* Repo root will hold the readme, gitignore, base requirements.txt
	* Project root (run start project within the repo root) will contain your classic project
	* conf root holds the settings module, base URLConf (urls.py) and must be a valid Python package (which means it contains an __init__.py module) (this folder is also generated by start project)
* [pip freeze — pip 18.0 documentation](https://pip.pypa.io/en/stable/reference/pip_freeze/)
* https://github.com/pydanny/cookiecutter-django
* Terms
	* Django project - the whole web app powered by Django
	* Django apps - the sub groupings within the project, some are third-party
	* INSTALLED_APPS is the list of Django apps used by the project
	* Third-party Django packages are simply pluggable Django apps that have been packaged with Python packaging tools
* Django encourages a new app for each feature, root URL slug, or data set
* The app’s name should be a plural version of its main model
	* it should also correlate with the root slug
* Keep apps small to avoid breaking them in the future
* Each app has py files called modules, these are common
	* admin
	* fors
	* models
	* urls
	* views
* These are less common
	* behaviors - model mixins
	* constants - app-level settings
	* context_processors
	* decorators - where to place them
	* db/ - custom models fields and components
	* exceptions
	* fields - form fields, model fields
	* factories - test data factories
	* helpers - synonymous with utils.py
	* managers - for when models.py grows too large
	* middleware -
	* signals - custom signals, though they are warned against
	* utils
	* viewmixins - another file or _dir_ possibility that lightens the main files
* Settings and Requirements
	* Keep a base settings file
	* Keep secret keys safe and out of version control
	* Keep Keys and Secrets out of settings files, store in ENV vars outside of version control
	* Have dev, staging, test, and production settings which inherit from a base settings files
	* Requires a _settings_ dir contains base.py, local.py, production.py, etc
	* Set DJANGO_SETTINGS_MODULE depending on environments
	* Email, databases, installed apps like debug toolbar, DEBUG var are all Local
	* With Django, avoid Apache because it’s ENV VARS system does not work
	* ENV VARS can be set in a variety of places, .bash files not included in VC, the bin/activate script for virtualenv, within your VM, Vagrant, etc etc
	* create get_env_variable function to enable settings files, it will provide a traceback when the var is not found
	* Dont import Django components into settings files, keep them for config only
	* Django-admin.py is recommended over manage.py, but may be more challenging
	* Each settings files should have a corresponding requirements files
	* Create a corresponding _requirements_ dir
	* Always use a relative path with BASE_DIR in settings, setting MEDIA_ROOT and STATIC_ROOT(s) that way
* Model Best Practices
	* django-model-utils contains common patterns such as TimeStampedModel
	* Django-extensions has a powerful management command called shell.plus which autoloaders the model classes for all apps. The downside is that it includes a lot of functions which hurt performance
	* 5 or fewer models er app, not 20+
	* Model Inheritance
		* Not using it: same field on multiple models is hard to maintain, but  it is easy to understand
		* Abstract base classes: Shares fields with parent class
		* Multi-table inheritance: Each model gets a table, and a OneToOneField is created to enable parent.child relationship (often considered a bad thing)
		* Proxy Model: have an alias of model with different behavior (fields cannot change)
	* Creating an abstract base class
		* add “class Meta: abstract = True”
		* without the abstract class, passing the other model as an arg to the new model would result in the new model creating 2 tables rather than properly inheriting
	* django.db.migrations after making change to model
	* use MIGRATION_MODULES for 3rd parties
	* consider squash migrations if there are many
	* always test the migration rollback
	* never migrate real data without extensive testing first
	* the bigger the table, the longer the migration
	* understand database normalization
		* explore caching before denormalization
	* GenericIPAddressField
	* Important fields
		* SlugField, UUIDField, ForeignKey, ManyToManyField
		* BinaryField - for base64 blobs, stream data, etc
	* set up proper foreign key relations in SQL (or in Mongo), proper indexing
	* use Model._meta to get list of fields, class of field, ensure through tests that this information remains constant on Django version
	* model manager (Django ORM)
		* objects = models.Manager() enables the use of a custom database.lookup.method() with special props like sorts and filters
	* fat models says DO NOT put any logic in views and templates, instead encapsulate the logic in model methods, class methods, etc
		* this does not mean to create “god objects” or models too large in size
		* use utils in addition to isolate code
		* Model Behaviors are AKA Mixins isolate code
			* which I believe actually are abstract base models
	* 

#department/development/codesnippets